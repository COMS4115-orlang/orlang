(* Let polymorphism; recursive let bindings used polymorphically
   outside of their definition and monomorphically inside of their
   definition; redundant recursion *)

val operator_add : Int -> Int -> Int
let operator_add x y = x _+ y

val operator_sub : Int -> Int -> Int
let operator_sub x y = x _- y

val operator_mlt : Int -> Int -> Int
let operator_mlt x y = x _* y

val operator_div : Int -> Int -> Int
let operator_div x y = x _/ y

val operator_mod : Int -> Int -> Int
let operator_mod x y = x _% y

val operator_and : Bool -> Bool -> Bool
let operator_and x y = x _&& y

val operator_or : Bool -> Bool -> Bool
let operator_or x y = x _|| y

val operator_not : Bool -> Bool
let operator_not x = _! x

let operator_eq x y = (x _== y) : Bool

val fac : Int -> Int
let rec fac n = 
  if n == 0 then 0
  else if n == 1 then 1
  else (fac (n - 1)) + (fac (n - 2))

val x : Int
let x = 20

val id : 'a -> 'a
let rec id = (\x -> x)

val applyFunc: ('b -> 'c) -> 'b -> 'c
let rec applyFunc f x = f x

let main = applyFunc (applyFunc id fac) (applyFunc id x)

