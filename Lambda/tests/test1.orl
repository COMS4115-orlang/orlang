(* Monomorphism; non-recursive let bindings; lambdas;
   multi-variable lambdas; nested comments; function
   application; currying; where clause desugaring *)

(* this is ignored *)
(* this is (* doubly *) ignored *)

val operator_add : Int -> Int -> Int
let operator_add x y = x _+ y

val operator_sub : Int -> Int -> Int
let operator_sub x y = x _- y

val operator_mlt : Int -> Int -> Int
let operator_mlt x y = x _* y

val operator_div : Int -> Int -> Int
let operator_div x y = x _/ y

val operator_mod : Int -> Int -> Int
let operator_mod x y = x _% y

val operator_and : Bool -> Bool -> Bool
let operator_and x y = x _&& y

val operator_or : Bool -> Bool -> Bool
let operator_or x y = x _|| y

val operator_not : Bool -> Bool
let operator_not x = _! x

let operator_eq x y = (x _== y) : Bool

val five : Int
let five =
  let f = (\x y -> 1 * (x - 2) * y) in 
  let g x y = x * y in
  let x = 3 in
  let y = 4 in
  f (g x 2 - 3) ((\z -> z + 1) y)

val five2 : Int
let five2 =
  f (g x 2 - 3) ((\z -> z + 1) y)
  where f = (\x y -> 1 * (x - 2) * y)
    and g x y = x * y
    and x = 3
    and y = 4

val five3 : Int
let five3 =
  z
  where f = (\x y -> 1 * (x - 2) * y)
    and g x y = x * y
    and x = 3 and y = 4
    and u = g x 2 - 3
    and v = (\z -> z + 1) y
    and z = f u v

val six : Int
let six = (\x -> \y -> 6) 3 6

let main = five * 1000 + five2 * 100 + five3 * 10 + six

